  <!doctype html>
  <html>
  <head>
      <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
      <meta name="description" content="A report generated by the MATLAB Report Generator."/>
      <meta name="generator" content="MATLAB Report Generator"/>
      <meta name="dc.creator" content="MathWorks, Inc." />
      <meta name="dc.description" lang="en" content="Default single-file template for formatting HTML reports" />
      <meta name="dc.identifier" content="default-rg-html-file" />
      <meta name="dc.title" lang="en" content="Default Single-File HTML Template" />
      <title>Report</title>
      
      <style>/*<![CDATA[*/ 
  /********************************************************
  *
  * Table of Contents (TOC) styles
  *
  * The TOC is a multilevel, collapsible list generated by
  * the script toc.js in the report's scripts directory.
  *
  *********************************************************/
  
  /* Title of TOC Section
     The TOC template in the report's document part template
     library defines the content and layout of the title.
  */
  span.rgTOCSectionTitle {
    font-family: Arial, Helvetica, sans-serif;
    font-weight: bold;
    font-size: 12pt;
  }
  
  /* TOC container */
  div.TOC {
      background-color: #f2f2f2; /* light gray */
  }
  
  /* top-level TOC entries */
  ul.TOCItems {
      list-style-type:none; /* no bullets */
      padding-left:1em;     /* Indent from left margin */
  }
  
  /* lower-level TOC entries */
  ul.TOCItems  ul {
    list-style-type:none;
    padding-left:1.2em;
  }
  
  /* Title of section targeted by this TOC entry */
  a.TOCItemTitle {
      font-family: Arial, Helvetica, sans-serif;
      font-size: 10pt;
      font-weight:bold;
      color:blue;
      text-decoration: underline;
  }                                                                            
  
  span.TOCHandle {
      display:block;
      float:left;
      height:10px;
      width:10px;
      background-color: transparent;
      border: 1px solid black;
      background-position: center bottom; 
      background-repeat: no-repeat;
      position:relative;
      top:2px;  
      margin-right:5pt;
      cursor:default;
  }
  
  
  span.TOCHandleCollapsed {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAA/SURBVChTY/wPBAxEACYoDQcNDQ1gjA4wFOICRCsEuxGbVcgAJI9i4t+/f6EsTIDha5jp6LbQyDNQNh7AwAAA5zEb+KbHji8AAAAASUVORK5CYII=");
  }
  
  span.TOCHandleCollapsed:hover {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4AITER4u94/hZAAAAAd0RVh0QXV0aG9yAKmuzEgAAAAMdEVYdERlc2NyaXB0aW9uABMJISMAAAAKdEVYdENvcHlyaWdodACsD8w6AAAADnRFWHRDcmVhdGlvbiB0aW1lADX3DwkAAAAJdEVYdFNvZnR3YXJlAF1w/zoAAAALdEVYdERpc2NsYWltZXIAt8C0jwAAAAh0RVh0V2FybmluZwDAG+aHAAAAB3RFWHRTb3VyY2UA9f+D6wAAAAh0RVh0Q29tbWVudAD2zJa/AAAABnRFWHRUaXRsZQCo7tInAAAAOUlEQVQYla2PsQ0AMAjDoI87n9OJhQrBUI9RlMgOhC04NZBkkubierEFiAkg1oterVOkCv2Xea47Lig/Mlx+VwdyAAAAAElFTkSuQmCC");
  }
  
  span.TOCHandleExpanded {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAArSURBVChTY/wPBAxEACYoTRBQXyHYjQ0NDVAudgCSJ81EKBsvGDBfMzAAAFYzDwbo3WvaAAAAAElFTkSuQmCC");
  }
  
  span.TOCHandleExpanded:hover {
      background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH4AITER8sAJqxCQAAAAd0RVh0QXV0aG9yAKmuzEgAAAAMdEVYdERlc2NyaXB0aW9uABMJISMAAAAKdEVYdENvcHlyaWdodACsD8w6AAAADnRFWHRDcmVhdGlvbiB0aW1lADX3DwkAAAAJdEVYdFNvZnR3YXJlAF1w/zoAAAALdEVYdERpc2NsYWltZXIAt8C0jwAAAAh0RVh0V2FybmluZwDAG+aHAAAAB3RFWHRTb3VyY2UA9f+D6wAAAAh0RVh0Q29tbWVudAD2zJa/AAAABnRFWHRUaXRsZQCo7tInAAAAKUlEQVQYlWOsr6//z0AEYCJGEW0UsjAwMDA0NDTgVdTQ0EC8iYxDwNcAN3oIDWPkPuEAAAAASUVORK5CYII=");
  }
   
 /*DOM MATLABTable styles */
 table.rgMATLABTable {
    text-align: center;
    border: none;
 }
 table.rgMATLABTable th {
    font-weight: bold;
    padding: 0pt 4pt 0pt 4pt;
 }
 table.rgMATLABTable td {
    padding: 0pt 4pt 0pt 4pt;
 }
 table.rgMATLABTable p {
    margin: 0pt 0pt 0pt 0pt;
 }

 /* Body */
  body {
      font-family: 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      counter-reset: chapter;
      margin: 0;
  }

  /* Headings */
  h1 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(54,95,145);
      font-size: 14pt;
      font-weight: bold;
      margin-top: 24pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h2 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(79,129,189);
      font-size: 13pt;
      font-weight: bold;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h3 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(79,129,189);
      font-size: 11pt;
      font-weight: bold;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h4 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(79,129,189);
      font-size: 11pt;
      font-weight: bold;
      font-style: italic;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h5 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(36,63,96);
      font-size: 11pt;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

  h6 {
      font-family: Cambria, 'Noto Sans', 'Noto Sans CJK JP', 'Noto Sans CJK SC', 'Noto Sans CJK KR';
      color: rgb(36,63,96);
      font-size: 11pt;
      font-style: italic;
      margin-top: 10pt;
      margin-bottom: 0pt;
      white-space: pre;
  }

 /* Styles for TOC sidebar */

  .toc-sidebar {
      height: 100%;
      width: 200px;
      background-color: #fff;
      position: fixed!important;
      display: none;
      z-index: 5;
      overflow: auto;
      word-break: break-all;
  }

  .toc-animate-left {
      position: relative;
      animation: animateleft 0.4s;
  }

  @keyframes animateleft {
      from {
          left: -300px;
          opacity: 0;
      }
      to {
          left: 0;
          opacity: 1;
      }
  }

  .overlay {
      position: fixed;
      display: none;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.2);
      z-index: 2;
  }

  .animate-opacity {
      animation: opac 0.8s;
  }

  @keyframes opac {
      from {
          opacity: 0;
      }
      to {
          opacity: 1;
      }
  }

  .toc-button {
      border: none;
      display: inline-block;
      padding: 8px 16px;
      font-size: 24px!important;
      vertical-align: middle;
      overflow: hidden;
      text-decoration: none;
      color: inherit;
      background-color: inherit;
      text-align: center;
      cursor: pointer;
      white-space: nowrap;
      position: fixed;
  }

  .toc-button:hover {
      color: #000!important;
      background-color: #ccc!important;
  }

  .container {
      padding: 0.01em 16px 16px 60px;
  }

  .current-toc-item {
      background-color: rgb(247, 175, 175);
  }

  
  /*]]>*/</style>
  
      <script>
          //<![CDATA[
  var cssrule;
  (function (cssrule) {
  
      function createStyleSheet() {
          var style = document.createElement("style");
  
          // Add a media (and/or media query) here if you'd like!
          // style.setAttribute("media", "screen")
          // style.setAttribute("media", "@media only screen and (max-width : 1024px)")
  
          // WebKit hack :(
          style.appendChild(document.createTextNode(""));
  
          // Add the <style> element to the page
          document.head.appendChild(style);
  
          return style.sheet;
      }
  
      function addCSSRule(selector, rules, index) {
          if (document.styleSheets) {
              var sheet = createStyleSheet();
              if (sheet) {
                  if (sheet.insertRule) {
                      return sheet.insertRule(selector + " {" + rules + "}", index);
                  }
                  else {
                      return sheet.addRule(selector, rules, index);
                  }
              }
          }
          return null;
      }
      cssrule.addCSSRule = addCSSRule;
  
  })(cssrule || (cssrule = {}));
          //]]>
      </script>
      
      <script>
          //<![CDATA[
  var toc;
  (function (toc) {
      var showDetails = false;
      var headingId = 0;
  
      function createOutline(outline, levels, level) {
          if (level <= levels) {
              var ul = document.createElement("ul");
              
              if (level == 1) {
                  ul.className = "TOCItems";
              } else {
                  ul.style.display = "none";
              }
              
              for (var i = 0; i < outline.length; i++) {
                  ul.appendChild(createSection(outline[i], levels, level));
              }
              
              return ul;
          }
          
          return null;
      }
      
      toc.createOutline = createOutline;
      
      /* 
       * Create an entry in the parent section's list of
       * subsections.
       */
      function createSection(section, levels, level) {
  
          // Create a hyper link to the section targeted
          // by this TOC entry.
          var title = document.createElement("a");
          title.className = "TOCItemTitle";
  
          
          if (section.heading === null) {
              switch (section.associatedNodes[0].nodeName.toLowerCase()) {
                  case "blockquote":
                      title.textContent = "Quoted content";
                      break;
                  case "body":
                      title.textContent = "Document";
                      break;
                  case "details":
                      title.textContent = "Widget";
                      break;
                  case "fieldset":
                      title.textContent = "Form controls";
                      break;
                  case "figure":
                      title.textContent = "Figure";
                      break;
                  case "td":
                      title.textContent = "Data cell";
                      break;
                  case "article":
                      title.textContent = "Article";
                      break;
                  case "aside":
                      title.textContent = "Aside";
                      break;
                  case "nav":
                      title.textContent = "Navigation";
                      break;
                  case "section":
                      title.textContent = "Section";
                      break;
              }
              title.className += "toc_no_title";
          } else {
              title.textContent = section.heading.text;
          }
  
          // Get this entry's target element.
          var linkTarget = section.associatedNodes[0];
          if ((linkTarget.sectionType !== 1 && linkTarget.sectionType !== 2) ||
              (linkTarget.nodeName.toLowerCase() === "body")) {
              linkTarget = section.heading;
          }
          
          // If the link target does not have an id,
          // provide it with a generated id.
          if (linkTarget.id == "") {
              ++headingId;
              linkTarget.id = "h" + headingId.toString();
          }
               
          title.href = "#" + linkTarget.id;
          
          // Create a list item to contain the
          // TOC entry and associated subsection list.
          var li = document.createElement("li");
          li.appendChild(title);
  
          // Recursively create a list of subsections of this section. 
          // If this section lacks subsections,the subsection list will
          // be empty.
          var subsectionList = createOutline(section.childSections, levels, level+1);
          
          if (subsectionList) {
              
              if (subsectionList.childElementCount > 0) {
                  
                  // The current section contains subsections.
                  // Add the list of subsections to this TOC
                  // entry.
                  li.appendChild(subsectionList);
                          
                  // Create the expand/collapse toggle handle.
                  var handle = document.createElement("span");
                  handle.className = "TOCHandle TOCHandleCollapsed";  
                  li.insertBefore(handle, li.childNodes[0]);             
  
                  // Add a click callback handler to hide or show
                  // the subsection TOC entries.
                  handle.addEventListener("click", function(event) {
                      event = event || window.event;
                      var handle = this;
                      
                      // Get this entry's subsection entry
                      // list
                      var li = handle.parentNode;
                      var sublist =  li.querySelector("UL");
                      
                      if (event.ctrlKey || event.metaKey) {
                      
                          var allExpanded = false;                       
                          if (sublist.style.display == "block") {
                              allExpanded = true;
                          }
              
                          var handleClassName = "TOCHandle TOCHandleExpanded";
                          var displayValue = "block";      
                          if (allExpanded) {
                              handleClassName = "TOCHandle TOCHandleCollapsed";
                              displayValue = "none";
                          } 
              
                          var handles = li.querySelectorAll("span.TOCHandle");
                          var i;       
                          for (i = 0; i < handles.length; i++) {
                              handles[i].className = handleClassName;
                          }
          
          
                          var lists = li.querySelectorAll("ul");
                          for (i = 0; i < handles.length; i++) {
                              lists[i].style.display = displayValue;
                          }
          
                          /*
                          if (displayValue = "none") {
                              var topList = tocContainer.querySelector("ul.TOCItems");
                              topList.style.display = "block";        
                          }
                          */
          
                          
                      } else {               
                          // Toggle display of the subsection entry list.
                          if (sublist != null) {
                              if (sublist.style.display == "none") {
                                  sublist.style.display = "block";
                                  handle.className = "TOCHandle TOCHandleExpanded";
                              } else {
                              sublist.style.display = "none";
                              handle.className = "TOCHandle TOCHandleCollapsed";
                              }
                          } 
                      }               
                      
                  });
                  }
              
          }
          return li;
      }
  
  
      function Section() {
          this.parentSection = null;
          this.childSections = [];
          this.firstChild = null;
          this.lastChild = null;
          this.appendChild = function (section) {
              section.parentSection = this;
              this.childSections.push(section);
              if (this.firstChild === null) {
                  this.firstChild = section;
              }
              this.lastChild = section;
          };
  
          this.heading = null;
  
          this.associatedNodes = [];
      }
      toc.Section = Section;
  
      function HTMLOutline(root) {
          var currentOutlinee = null;
  
          var currentSection = null;
  
          var stack = { "lastIndex": -1, "isEmpty": null, "push": null, "pop": null, "top": null };
          stack.isEmpty = function () {
              return stack.lastIndex === -1;
          };
          stack.push = function (e) {
              stack[++stack.lastIndex] = e;
              stack.top = e;
          };
          stack.pop = function () {
              var e = stack.top;
              delete stack[stack.lastIndex--];
              stack.top = stack[stack.lastIndex];
              return e;
          };
          
          function enter(node) {
              if (isElement(node)) {
                  if (!stack.isEmpty() && (isHeadingElement(stack.top) || isHidden(stack.top))) {
                      return;
                  }
                  
                  if (isHidden(node)) {
                      stack.push(node);
                      return;
                  }
                  
                  if (isSectioningContentElement(node) || isSectioningRootElement(node)) {
                      if (currentOutlinee !== null) {
                          stack.push(currentOutlinee);
                      }
                      currentOutlinee = node;
                      currentSection = new Section();
                      associateNodeWithSection(currentOutlinee, currentSection);
                      currentOutlinee.appendSection(currentSection);
                      return;
                  }
                  
                  if (currentOutlinee === null) {
                      return;
                  }
                  
                  if (isHeadingElement(node)) {
                      if (currentSection.heading === null) {
                          currentSection.heading = node;
                          return;
                       }
                       
                      if (currentOutlinee.lastSection.heading === null || node.rank >= currentOutlinee.lastSection.heading.rank) {
                          currentSection = new Section();
                          currentSection.heading = node;
                          currentOutlinee.appendSection(currentSection);
                      } else {
                          var candidateSection = currentSection;
                          do {
                              if (node.rank < candidateSection.heading.rank) {
                                  currentSection = new Section();
                                  currentSection.heading = node;
                                  candidateSection.appendChild(currentSection);
                                  break;
                              }
                              var newCandidate = candidateSection.parentSection;
                              candidateSection = newCandidate;
                          } while(true);
                      }
                      stack.push(node);
                  }
              }
          }
  
          function exit(node) {
              if (isElement(node)) {
                  if (!stack.isEmpty() && node === stack.top) {
                      stack.pop();
                  } else if (!stack.isEmpty() && (isHeadingElement(stack.top) || isHidden(stack.top))) {
                  } else if (!stack.isEmpty() && isSectioningContentElement(node)) {
                      currentOutlinee = stack.pop();
                      currentSection = currentOutlinee.lastSection;
                      for (var i = 0; i < node.sectionList.length; i++) {
                          currentSection.appendChild(node.sectionList[i]);
                      }
                  } else if (!stack.isEmpty() && isSectioningRootElement(node)) {
                      currentOutlinee = stack.pop();
                      currentSection = currentOutlinee.lastSection;
                      while (currentSection.childSections.length > 0) {
                          currentSection = currentSection.lastChild;
                      }
                  } else if (isSectioningContentElement(node) || isSectioningRootElement(node)) {
                      currentOutlinee = null;
                      currentSection = null;
                  }
              }
              if (node.associatedSection === null && currentSection !== null) {
                  associateNodeWithSection(node, currentSection);
              }
          }
  
          function associateNodeWithSection(node, section) {
              section.associatedNodes.push(node);
              node.associatedSection = section;
          }
  
          function isElement(node) {
              return node.nodeType === 1;
          }
  
          function isHidden(node) {
              return node.hidden;
          }
  
          function isSectioningContentElement(node) {
              return node.sectionType === 1;
          }
  
          function isSectioningRootElement(node) {
              return node.sectionType === 2;
          }
  
          function isHeadingElement(node) {
              return node.rank !== undefined;
          }
  
          function extend(node) {
              if (node.nodeType === 1) {
                  switch (node.nodeName.toLowerCase()) {
                      case "blockquote":
                      case "body":
                      case "details":
                      case "dialog":
                      case "fieldset":
                      case "figure":
                      case "td":
                          extendSectioningRootElement(node);
                          break;
                      case "article":
                      case "aside":
                      case "nav":
                      case "section":
                          extendSectioningContentElement(node);
                          break;
                      case "h1":
                      case "h2":
                      case "h3":
                      case "h4":
                      case "h5":
                      case "h6":
                          extendHeadingElement(node);
                          break;
                      case "hgroup":
                          extendHeadingGroupElement(node);
                          break;
                      default:
                          extendNode(node);
                  }
              } else
                  extendNode(node);
          }
  
          function extendNode(node) {
              node.associatedSection = null;
          }
  
          function extendSectioningElement(node) {
              extendNode(node);
              node.sectionList = [];
              node.firstSection = null;
              node.lastSection = null;
  
              node.appendSection = function (section) {
                  this.sectionList.push(section);
                  if (this.firstSection === null) {
                      this.firstSection = section;
                  }
                  this.lastSection = section;
              };
          }
  
          function extendSectioningContentElement(node) {
              extendSectioningElement(node);
              node.sectionType = 1;
          }
  
          function extendSectioningRootElement(node) {
              extendSectioningElement(node);
              node.sectionType = 2;
          }
  
          function extendHeadingContentElement(node) {
              extendNode(node);
              Object.defineProperty(node, "depth", {
                  "get": function () {
                      var section = node.associatedSection;
                      var depth = 1;
                      if (section !== null) {
                          while (section = section.parentSection)
                              ++depth;
                      }
                      return depth;
                  },
                  "configurable": true,
                  "enumerable": true
              });
          }
  
          function extendHeadingElement(node) {
              extendHeadingContentElement(node);
              node.rank = -parseInt(node.nodeName.charAt(1));
              node.text = node.textContent;
          }
  
          function extendHeadingGroupElement(node) {
              extendHeadingContentElement(node);
  
              for (var i = 1; i <= 6; i++) {
                  var h = node.getElementsByTagName("h" + i);
                  if (h.length > 0) {
                      node.rank = -i;
                      node.text = h[0].textContent;
                      break;
                  }
              }
  
              if (node.rank === undefined) {
                  node.rank = -1;
                  node.text = "";
              }
          }
  
          var node = root;
          start:
          while (node) {
              extend(node);
              enter(node);
              if (node.firstChild) {
                  node = node.firstChild;
                  continue start;
              }
              while (node) {
                  exit(node);
                  if (node === root) {
                      break start;
                  }
                  if (node.nextSibling) {
                      node = node.nextSibling;
                      continue start;
                  }
                  node = node.parentNode;
              }
          }
      }
      toc.HTMLOutline = HTMLOutline;

      function createSideBar() {
            // If TOC is generated, this method will manipulate the DOM to create the sidebar overlay
            var toc_element = document.querySelector('div#tocContainer, toc');

            // Get parent div that is written by document part of the TableOfContents reporter
            // and remove it from the body
            var tocParentDiv = toc_element.parentElement;
            document.body.removeChild(tocParentDiv);

            // Get all the body content now, this will exclude TOC. Wrap them in container div
            var contentWrapper = document.createElement('div');
            contentWrapper.className = 'container';

            // Move the body's children into this wrapper and then append wrapper to the body
            while (document.body.firstChild) {
                contentWrapper.appendChild(document.body.firstChild);
            }
            document.body.appendChild(contentWrapper);            

            // Add button to open TOC side bar
            var tocButton = document.createElement('button');
            tocButton.innerHTML = '&#9776';
            tocButton.className = 'toc-button';

            // Add mouse events to open and close TOC
            tocButton.addEventListener("mouseover", function() {
                openTOC();

                highlightSelectedEntry();

                var sideBar = document.getElementById("TOCSidebar");
                sideBar.addEventListener("mouseleave", closeTOC);
            });

            // Add touch events to open and close TOC
            tocButton.addEventListener("touchstart", function() {
                openTOC();

                highlightSelectedEntry();

                var overlay = document.getElementById("TOCOverlay");
                overlay.addEventListener("touchstart", closeTOC);
            });

            contentWrapper.parentNode.insertBefore(tocButton, contentWrapper);

            // Add div for overlay
            var overlayDiv = document.createElement('div');
            overlayDiv.id = 'TOCOverlay';
            overlayDiv.className = 'overlay animate-opacity';
            tocButton.parentNode.insertBefore(overlayDiv, tocButton);

            // Wrap toc in a div for sidebar and add it before overlay div
            var tocWrapper = document.createElement('div');
            tocWrapper.id = 'TOCSidebar';
            tocWrapper.className = 'toc-sidebar toc-animate-left';
            tocWrapper.appendChild(tocParentDiv);
            overlayDiv.parentNode.insertBefore(tocWrapper, overlayDiv);

            // Function to open TOC sidebar
            function openTOC() {
                document.getElementById("TOCSidebar").style.display = "block";
                document.getElementById("TOCOverlay").style.display = "block";
	   }

            // Function to close TOC sidebar
            function closeTOC() {
                document.getElementById("TOCSidebar").style.display = "none";
                document.getElementById("TOCOverlay").style.display = "none";
	   }

            // Function to highlight the selected entry in the TOC
            function highlightSelectedEntry() {
                var tocItemList = document.getElementsByClassName('TOCItemTitle');
                for (var i = 0; i < tocItemList.length; i++) {
                    tocItemList[i].addEventListener('click', function(event) {
                        for (var j = 0; j < tocItemList.length; j++) {
                            tocItemList[j].classList.remove('current-toc-item');
                        }
                        event.target.classList.add('current-toc-item');
                    });
                }
            }
          }
          toc.createSideBar = createSideBar;

  })(toc || (toc = {}));
          //]]>
      </script>
      
      <script>
          //<![CDATA[
          var util;
  (function (util) {
    function toggleTOCVisibility(event, handleId, tocTag) {
      event = event || window.event;
    
      var tocContainer = document.querySelector(tocTag);
      var containerHandle = document.getElementById(handleId);
      
      if (event.ctrlKey || event.metaKey) {
      
          if (!containerHandle.hasOwnProperty("AllExpanded")) {
              containerHandle.AllExpanded = false;
          }
          
          var allExpanded = false;
          if (containerHandle.AllExpanded) {
              allExpanded = true;
          }
              
          var handleClassName = "TOCHandle TOCHandleExpanded";
          var displayValue = "block";
          
          if (allExpanded) {
              handleClassName = "TOCHandle TOCHandleCollapsed";
              displayValue = "none";
          } 
              
          var handles = tocContainer.querySelectorAll("span.TOCHandle");
          var i;       
          for (i = 0; i < handles.length; i++) {
              handles[i].className = handleClassName;
          }
          
          
          var lists = tocContainer.querySelectorAll("ul");
          for (i = 0; i < lists.length; i++) {
              lists[i].style.display = displayValue;
          }
          
          if (displayValue == "none") {
              var topList = tocContainer.querySelector("ul.TOCItems");
              topList.style.display = "block";        
          }
          
          containerHandle.AllExpanded = !allExpanded;
          
          tocContainer.style.display = displayValue;
          containerHandle.className = handleClassName;
          
      } else {
  
          if (tocContainer.style.display == "block") {
              tocContainer.style.display = "none";
              containerHandle.className = "TOCHandle TOCHandleCollapsed";
          } else {
              tocContainer.style.display = "block";
              containerHandle.className = "TOCHandle TOCHandleExpanded";
          }
      }
    }
    
    util.toggleTOCVisibility = toggleTOCVisibility;
    
      function autoNumber() {
      
              function alphabetize(n) {
                  var ordA = 'A'.charCodeAt(0);
                  var ordZ = 'Z'.charCodeAt(0);
                  var len = ordZ - ordA + 1;
        
                  var s = "";
                  while(n >= 0) {
                      s = String.fromCharCode(n % len + ordA-1) + s;
                      n = Math.floor(n / len) - 1;
                  }
                  return s;
              }
      
              function romanize (num) {
              if (!+num)
              return false;
              var	digits = String(+num).split(""),
              key = ["","C","CC","CCC","CD","D","DC","DCC","DCCC","CM",
                 "","X","XX","XXX","XL","L","LX","LXX","LXXX","XC",
                 "","I","II","III","IV","V","VI","VII","VIII","IX"],
              roman = "",
              i = 3;
              while (i--)
              roman = (key[+digits.pop() + (i * 10)] || "") + roman;
              return Array(+digits.join("") + 1).join("M") + roman;
          }
          
          function formatNumber(number, format) {
              var formattedNumber =  "";
              switch (format) {
                  case "n":
                  case "N":
                      formattedNumber = number.toString();
                  break;
                  case "a":
                      formattedNumber = alphabetize(number).toLowerCase();
                      break;
                  case "A":
                      formattedNumber = alphabetize(number);
                      break;
                  case "i":
                      formattedNumber = romanize(number).toLowerCase();
                  break;
                  case "I":
                      formattedNumber = romanize(number);
                  break;
                  default:
                      formattedNumber = number.toString();
              }
              return formattedNumber;
          }
          
      var nodes = document.querySelectorAll("h1, h2, h3, h4, h5, h6, autonumber");
      var h1Counter = 0;
      var h2Counter = 0;
      var h3Counter = 0;
      var h4Counter = 0;
      var h5Counter = 0;
      var h6Counter = 0;
      for (var i = 0; i < nodes.length; i++) {
          node = nodes[i];
          switch (node.nodeName.toLowerCase()) {
              case "h1":
                  h1Counter = h1Counter + 1;
                  h2Counter = 0;
                  break;
              case "h2":
                  h2Counter = h2Counter + 1;
                  h3Counter = 0;
                  break;
              case "h3":
                  h3Counter = h3Counter + 1;
                  h4Counter = 0;              
                  break;
              case "h4":
                  h4Counter = h4Counter + 1;
                  h5Counter = 0;
                  break;
              case "h5":
                  h5Counter = h5Counter + 1;
                  h6Counter = 0;
                  break;
              case "h6":
                  h6Counter = h6Counter + 1;
                  break;
              case "autonumber":
                  var counterName = node.getAttribute("stream-name");
                  switch (counterName.toLowerCase()) {
                      case "h1":
                          number = h1Counter;
                          break;
                      case "h2":
                          number = h2Counter;
                          break;
                      case "h3":
                          number = h3Counter;             
                          break;
                      case "h4":
                          number = h4Counter;
                          break;
                      case "h5":
                          number = h5Counter;
                          break;
                      case "h6":
                          number = h6Counter;
                          break;
                  }
                  var format = node.getAttribute("format");
                  format = format ? format : "n";
                  node.innerHTML = formatNumber(number, format);
                  break
              default:
                  number = "";
          }
          
          
      } 
    }
    
    util.autoNumber = autoNumber;
    
    
  })(util || (util = {}))
                 //]]>
      </script>
      
      <script>
          //<![CDATA[
          function outline() {
              util.autoNumber();
              var toc_elements = document.querySelectorAll('div#tocContainer, toc');
              if (toc_elements.length != 0) {
                  var content = document.body;
                  toc.HTMLOutline(content);
                  if (content.sectionList) {
                      for (var toc_index = 0; toc_index < toc_elements.length; ++toc_index) {
                          var toc_element = toc_elements[toc_index];
                          var toc_levels = 6;
                          var toc_levels_attribute = toc_element.getAttribute('number-of-levels');
                          if (toc_levels_attribute) {
                              toc_levels = Number(toc_levels_attribute);
                          }
                          toc_element.appendChild(toc.createOutline(content.sectionList,toc_levels, 1));
                      }
                  }
                  
                  // Create the sidebar for the TOC
                  toc.createSideBar();
              }
          }
          //]]>
      </script>
  </head>
  
  <body bgcolor="white" text="black" onload="outline()"> 
      <dplibrary>
      </dplibrary>
  </body>
  </html>
